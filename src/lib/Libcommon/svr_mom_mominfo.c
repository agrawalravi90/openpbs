/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

#include <pbs_config.h> /* the master config generated by configure */

#include "attribute.h"
#include "batch_request.h"
#include "credential.h"
#include "hook_func.h"
#include "libpbs.h"
#include "list_link.h"
#include "log.h"
#include "pbs_error.h"
#include "pbs_internal.h"
#include "pbs_nodes.h"
#include "resource.h"
#include "server.h"
#include "server_limits.h"
#include "svrfunc.h"
#include "tpp.h"
#include "work_task.h"
#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

static char merr[] = "malloc failed";

/* Global Data Itmes */

/* mominfo_array is an array of mominfo_t pointers, one per host */

mominfo_t **mominfo_array = NULL;
int mominfo_array_size = 0;	      /* num entries in the array */
mominfo_time_t mominfo_time = {0, 0}; /* time stamp of mominfo update */

extern char *msg_daemonname;
extern char *path_hooks_rescdef;

#define GROW_MOMINFO_ARRAY_AMT 10

/**
 * @brief
 *		create_mom_entry - create both a mominfo_t entry and insert a pointer
 *		to that element into the mominfo_array which may be expanded if needed
 *
 * @par Functionality:
 *		Searches for existing mominfo_t entry with matching hostname and port;
 *		if found returns it, otherwise adds entry.   An empty slot in the
 *		mominfo_array[] will be used to hold pointer to created entry.  If no
 *		empty slot, the array is expanded by GROW_MOMINFO_ARRAY_AMT amount.
 *
 * @param[in]	hostname - hostname of host on which Mom will be running
 * @param[in]	port     - port number to which Mom will be listening
 *
 * @return	mominfo_t *
 * @retval	Returns pointer to the mominfo entry, existing or created
 * @retval	NULL on error.
 *
 * @par Side Effects: None
 *
 * @par MT-safe: no, would need lock on realloc of global mominfo_array[]
 *
 */

mominfo_t *
create_mom_entry(char *hostname, unsigned int port)
{
	int empty = -1;
	int i;
	mominfo_t *pmom;
	mominfo_t **tp;

	for (i = 0; i < mominfo_array_size; ++i) {
		pmom = mominfo_array[i];
		if (pmom) {
			if ((strcasecmp(pmom->mi_host, hostname) == 0) &&
			    (pmom->mi_port == port))
				return pmom;
		} else if (empty == -1) {
			empty = i; /* save index of first empty slot */
		}
	}

	if (empty == -1) {
		/* there wasn't an empty slot in the array we can use */
		/* need to grow the array			      */

		tp = (mominfo_t **) realloc(mominfo_array,
					    (size_t)(sizeof(mominfo_t *) * (mominfo_array_size + GROW_MOMINFO_ARRAY_AMT)));
		if (tp) {
			empty = mominfo_array_size;
			mominfo_array = tp;
			mominfo_array_size += GROW_MOMINFO_ARRAY_AMT;
			for (i = empty; i < mominfo_array_size; ++i)
				mominfo_array[i] = NULL;
		} else {
			log_err(errno, __func__, merr);
			return NULL;
		}
	}

	/* now allocate the memory for the mominfo_t element itself */

	pmom = (mominfo_t *) malloc(sizeof(mominfo_t));
	if (pmom) {
		(void) strncpy(pmom->mi_host, hostname, PBS_MAXHOSTNAME);
		pmom->mi_host[PBS_MAXHOSTNAME] = '\0';
		pmom->mi_port = port;
		pmom->mi_rmport = port + 1;
		pmom->mi_modtime = (time_t) 0;
		pmom->mi_data = NULL;
		pmom->mi_action = NULL;
		pmom->mi_num_action = 0;
#ifndef PBS_MOM
		if (mom_hooks_seen_count() > 0) {
			struct stat sbuf;
			/*
			 * there should be at least one hook to
			 * add mom actions below, which are in
			 * behalf of existing hooks.
			 */
			add_pending_mom_allhooks_action(pmom, MOM_HOOK_ACTION_SEND_ATTRS | MOM_HOOK_ACTION_SEND_CONFIG | MOM_HOOK_ACTION_SEND_SCRIPT);
			if (stat(path_hooks_rescdef, &sbuf) == 0)
				add_pending_mom_hook_action(pmom, PBS_RESCDEF, MOM_HOOK_ACTION_SEND_RESCDEF);
		}
#endif

		mominfo_array[empty] = pmom;
	} else {
		log_err(errno, __func__, merr);
	}

	return pmom;
}

/**
 *
 * @brief
 *		Destory a mominfo_t element and null the pointer to that
 *		element in the mominfo_array;
 * @par Functionality:
 *		The heap entry pointed to by the mi_data member is freed also.
 *		However, any extra malloc-ed space in that member must be freed
 *		independently. Note, this means the mominfo_array may have null
 *		entries anywhere.
 *
 * @param[in]	pmom - the element being operated on.
 *
 * @return	void
 */

void
delete_mom_entry(mominfo_t *pmom)
{
	int i;

	if (pmom == NULL)
		return;

	/*
	 * Remove any work_task entries that may be referencing this mom
	 * BEFORE we free any data.
	 */
	delete_task_by_parm1_func((void *) pmom, NULL, DELETE_ONE);

	/* find the entry in the arry that does point here */
	for (i = 0; i < mominfo_array_size; ++i) {
		if (mominfo_array[i] == pmom) {
			mominfo_array[i] = NULL;
			break;
		}
	}

	if (pmom->mi_action != NULL) {

#ifndef PBS_MOM
		for (i = 0; i < pmom->mi_num_action; ++i) {
			if (pmom->mi_action[i] != NULL) {
				free(pmom->mi_action[i]);
				pmom->mi_action[i] = NULL;
			}
		}
#endif
		free(pmom->mi_action);
	}

	/* free the mi_data after all hook work is done, since the hook actions
	 * use the mi_data.
	 */
	if (pmom->mi_data)
		free(pmom->mi_data);

	memset(pmom, 0, sizeof(mominfo_t));
	free(pmom);

	return;
}

/**
 * @brief
 * 		find_mom_entry - find and return a pointer to a mominfo_t element
 *		defined by the hostname and port
 * @note
 *		the mominfo_array may have null entries anywhere.
 *
 * @param[in]	hostname - hostname of host on which Mom will be running
 * @param[in]	port     - port number to which Mom will be listening
 *
 * @return	pointer to a mominfo_t element
 * @reval	NULL	- couldn't find.
 */

mominfo_t *
find_mom_entry(char *hostname, unsigned int port)
{
	int i;
	mominfo_t *pmom;

	for (i = 0; i < mominfo_array_size; ++i) {
		pmom = mominfo_array[i];
		if (pmom &&
		    (strcasecmp(pmom->mi_host, hostname) == 0) &&
		    (pmom->mi_port == port))
			return pmom;
	}

	return NULL; /* didn't find it */
}
