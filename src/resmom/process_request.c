/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

/**
 * @file    process_request.c
 *
 * @brief
 *  process_request - this function gets, checks, and invokes the proper
 *	function to deal with a batch request received over the network.
 *
 *	All data encoding/decoding dependencies are moved to a lower level
 *	routine.  That routine must convert
 *	the data received into the internal server structures regardless of
 *	the data structures used by the encode/decode routines.  This provides
 *	the "protocol" and "protocol generation tool" freedom to the bulk
 *	of the server.
 *
 * Functions included are:
 *	pbs_crypt_des()
 *	get_credential()
 *	process_request()
 *	set_to_non_blocking()
 *	clear_non_blocking()
 *	dispatch_request()
 *	close_client()
 *	alloc_br()
 *	close_quejob()
 */
#include <pbs_config.h> /* the master config generated by configure */

#include <assert.h>
#include <errno.h>
#include <memory.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>
#ifndef WIN32
#include <dlfcn.h>
#include <fcntl.h>
#include <grp.h>
#include <pwd.h>
#endif
#include "attribute.h"
#include "auth.h"
#include "batch_request.h"
#include "credential.h"
#include "dis.h"
#include "job.h"
#include "libpbs.h"
#include "list_link.h"
#include "log.h"
#include "net_connect.h"
#include "pbs_error.h"
#include "pbs_nodes.h"
#include "pbs_sched.h"
#include "server.h"
#include "server_limits.h"
#include "svrfunc.h"
#include "ticket.h"
#include "tpp.h"
#include "user.h"
#include <ctype.h>

/* global data items */

pbs_list_head svr_requests;

extern pbs_list_head svr_newjobs;
extern pbs_list_head svr_allconns;
extern time_t time_now;
extern char *msg_err_noqueue;
extern char *msg_err_malloc;
extern char *msg_reqbadhost;
extern char *msg_request;
extern char *msg_auth_request;

extern int is_local_root(char *, char *);
extern void req_stat_hook(struct batch_request *);

static void close_quejob(int sfds);

/*
* @brief
 * 		process_request - process an request from the network:
 *		Call function to read in the request and decode it.
 *		Validate requesting host and user.
 *		Call function to process request based on type.
 *		That function MUST free the request by calling free_br()
 *
 * @param[in]	sfds	- file descriptor (socket) to get request
 */

void
process_request(int sfds)
{
	int rc;
	struct batch_request *request;
	conn_t *conn;

	time_now = time(NULL);

	conn = get_conn(sfds);

	if (!conn) {
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_REQUEST, LOG_ERR, __func__, "did not find socket in connection table");
		CLOSESOCKET(sfds);
		return;
	}

	if ((request = alloc_br(0)) == NULL) {
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_REQUEST, LOG_ERR, __func__, "Unable to allocate request structure");
		close_conn(sfds);
		return;
	}
	request->rq_conn = sfds;
	if (get_connecthost(sfds, request->rq_host, PBS_MAXHOSTNAME)) {
		log_eventf(PBSEVENT_DEBUG, PBS_EVENTCLASS_REQUEST, LOG_DEBUG, __func__, "%s: %lu", msg_reqbadhost, get_connectaddr(sfds));
		req_reject(PBSE_BADHOST, 0, request);
		return;
	}

	/*
	 * Read in the request and decode it to the internal request structure.
	 */
	rc = dis_request_read(sfds, request);

	if (rc == -1) { /* End of file */
		close_client(sfds);
		free_br(request);
		return;
	} else if ((rc == PBSE_SYSTEM) || (rc == PBSE_INTERNAL)) {
		/* read error, likely cannot send reply so just disconnect */

		/* ??? not sure about this ??? */

		close_client(sfds);
		free_br(request);
		return;
	} else if (rc > 0) {
		/*
		 * request didn't decode, either garbage or unknown
		 * request type, in ether case, return reject-reply
		 */
		req_reject(rc, 0, request);
		close_client(sfds);
		return;
	}

	log_eventf(PBSEVENT_DEBUG2, PBS_EVENTCLASS_REQUEST, LOG_DEBUG, "", msg_request, request->rq_type, request->rq_user, request->rq_host, sfds);

	if (request->rq_type == PBS_BATCH_Authenticate) {
		req_authenticate(conn, request);
		return;
	}

	/* check connecting host against allowed list of ok clients */
	if (!addrfind(conn->cn_addr)) {
		req_reject(PBSE_BADHOST, 0, request);
		close_client(sfds);
		return;
	}

	if ((conn->cn_authen & PBS_NET_CONN_FROM_PRIVIL) == 0) {
		req_reject(PBSE_BADCRED, 0, request);
		close_client(sfds);
		return;
	}

	request->rq_fromsvr = 1;
	request->rq_perm = ATR_DFLAG_USRD | ATR_DFLAG_USWR |
			   ATR_DFLAG_OPRD | ATR_DFLAG_OPWR |
			   ATR_DFLAG_MGRD | ATR_DFLAG_MGWR |
			   ATR_DFLAG_SvWR | ATR_DFLAG_MOM;

	/*
	 * dispatch the request to the correct processing function.
	 * The processing function must call reply_send() to free
	 * the request struture.
	 */

	dispatch_request(sfds, request);
	return;
}

/**
 * @brief
 * 		Determine the request type and invoke the corresponding
 *		function.
 * @par
 *		The function will perform the request action and return the
 *		reply.  The function MUST also reply and free the request by calling
 *		reply_send().
 *
 * @param[in]	sfds	- socket connection
 * @param[in]	request - the request information
 */

void
dispatch_request(int sfds, struct batch_request *request)
{

	conn_t *conn = NULL;
	int prot = request->prot;

	if (prot == PROT_TCP) {
		if (sfds != PBS_LOCAL_CONNECTION) {
			conn = get_conn(sfds);
			if (!conn) {
				log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_REQUEST, LOG_ERR, __func__, "did not find socket in connection table");
				req_reject(PBSE_SYSTEM, 0, request);
				close_client(sfds);
				return;
			}
		}
	}

	switch (request->rq_type) {

	case PBS_BATCH_QueueJob:
		if (prot == PROT_TPP) {
			request->tpp_ack = 0;
			tpp_add_close_func(sfds, close_quejob);
		} else
			net_add_close_func(sfds, close_quejob);
		req_quejob(request);
		break;

	case PBS_BATCH_JobCred:
		if (prot == PROT_TPP)
			request->tpp_ack = 0;
		req_jobcredential(request);
		break;

	case PBS_BATCH_UserCred:
#ifdef WIN32
		req_reject(PBSE_NOSUP, 0, request);
#else
		req_reject(PBSE_UNKREQ, 0, request);
#endif
		close_client(sfds);
		break;

	case PBS_BATCH_jobscript:
		if (prot == PROT_TPP)
			request->tpp_ack = 0;
		req_jobscript(request);
		break;

		/*
			 * The PBS_BATCH_Rdytocommit message is deprecated.
			 * The server does not do anything with it anymore, but
			 * simply acks the request (in case some client makes this call)
			 */
	case PBS_BATCH_RdytoCommit:
		if (prot == PROT_TPP)
			request->tpp_ack = 0;
		reply_ack(request);
		break;

	case PBS_BATCH_Commit:
		if (prot == PROT_TPP)
			request->tpp_ack = 0;
		req_commit(request);
		if (prot == PROT_TPP)
			tpp_add_close_func(sfds, (void (*)(int)) 0);
		else
			net_add_close_func(sfds, (void (*)(int)) 0);
		break;

	case PBS_BATCH_DeleteJob:
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
			  request->rq_ind.rq_delete.rq_objname,
			  "delete job request received");
		req_deletejob(request);
		break;

	case PBS_BATCH_HoldJob:
		if (sfds != PBS_LOCAL_CONNECTION && prot == PROT_TCP)
			conn->cn_authen |= PBS_NET_CONN_NOTIMEOUT;
		req_holdjob(request);
		break;

	case PBS_BATCH_MessJob:
		req_messagejob(request);
		break;

	case PBS_BATCH_PySpawn:
		if (sfds != PBS_LOCAL_CONNECTION && prot == PROT_TCP)
			conn->cn_authen |= PBS_NET_CONN_NOTIMEOUT;
		req_py_spawn(request);
		break;

	case PBS_BATCH_ModifyJob:
	case PBS_BATCH_ModifyJob_Async:
		req_modifyjob(request);
		break;

	case PBS_BATCH_Rerun:
		req_rerunjob(request);
		break;

	case PBS_BATCH_Shutdown:
		req_shutdown(request);
		break;

	case PBS_BATCH_SignalJob:
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
			  request->rq_ind.rq_signal.rq_jid,
			  "signal job request received");
		req_signaljob(request);
		break;

	case PBS_BATCH_MvJobFile:
		req_mvjobfile(request);
		break;

	case PBS_BATCH_CopyFiles:
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
			  request->rq_ind.rq_cpyfile.rq_jobid,
			  "copy file request received");
		/* don't time-out as copy may take long time */
		if (sfds != PBS_LOCAL_CONNECTION && prot == PROT_TCP)
			conn->cn_authen |= PBS_NET_CONN_NOTIMEOUT;
		req_cpyfile(request);
		break;
	case PBS_BATCH_CopyFiles_Cred:
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
			  request->rq_ind.rq_cpyfile_cred.rq_copyfile.rq_jobid,
			  "copy file cred request received");
		/* don't time-out as copy may take long time */
		if (sfds != PBS_LOCAL_CONNECTION && prot == PROT_TCP)
			conn->cn_authen |= PBS_NET_CONN_NOTIMEOUT;
		req_cpyfile(request);
		break;

	case PBS_BATCH_DelFiles:
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
			  request->rq_ind.rq_cpyfile.rq_jobid,
			  "delete file request received");
		req_delfile(request);
		break;
	case PBS_BATCH_DelFiles_Cred:
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
			  request->rq_ind.rq_cpyfile_cred.rq_copyfile.rq_jobid,
			  "delete file cred request received");
		req_delfile(request);
		break;
	case PBS_BATCH_CopyHookFile:
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_HOOK,
			  LOG_INFO,
			  request->rq_ind.rq_hookfile.rq_filename,
			  "copy hook-related file request received");
		req_copy_hookfile(request);
		break;
	case PBS_BATCH_DelHookFile:
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_HOOK,
			  LOG_INFO,
			  request->rq_ind.rq_hookfile.rq_filename,
			  "delete hook-related file request received");
		req_del_hookfile(request);
		break;

#if defined(PBS_SECURITY) && (PBS_SECURITY == KRB5)
	case PBS_BATCH_Cred:
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB,
			  LOG_INFO,
			  request->rq_ind.rq_cred.rq_jobid,
			  "credentials received");
		req_cred(request);
		break;
#endif
	default:
		req_reject(PBSE_UNKREQ, 0, request);
		close_client(sfds);
		break;
	}
	return;
}

/**
 * @brief
 * 		close_quejob - locate and deal with the new job that was being received
 *		  when the net connection closed.
 *
 * @param[in]	sfds	- file descriptor (socket) to get request
 */

static void
close_quejob(int sfds)
{
	job *pjob;

	pjob = GET_NEXT(svr_newjobs);
	while (pjob != NULL) {
		if (pjob->ji_qs.ji_un.ji_newt.ji_fromsock == sfds) {
			if (pjob->ji_qs.ji_substate != JOB_SUBSTATE_TRANSICM) {
				delete_link(&pjob->ji_alljobs);
				job_purge_generic(pjob);
			}
			break;
		}
		pjob = GET_NEXT(pjob->ji_alljobs);
	}
}
