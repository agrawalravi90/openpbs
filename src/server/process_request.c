/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of both the OpenPBS software ("OpenPBS")
 * and the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * OpenPBS is free software. You can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * OpenPBS is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * PBS Pro is commercially licensed software that shares a common core with
 * the OpenPBS software.  For a copy of the commercial license terms and
 * conditions, go to: (http://www.pbspro.com/agreement.html) or contact the
 * Altair Legal Department.
 *
 * Altair's dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of OpenPBS and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair's trademarks, including but not limited to "PBS™",
 * "OpenPBS®", "PBS Professional®", and "PBS Pro™" and Altair's logos is
 * subject to Altair's trademark licensing policies.
 */


/**
 * @file    process_request.c
 *
 * @brief
 *  process_request - this function gets, checks, and invokes the proper
 *	function to deal with a batch request received over the network.
 *
 *	All data encoding/decoding dependencies are moved to a lower level
 *	routine.  That routine must convert
 *	the data received into the internal server structures regardless of
 *	the data structures used by the encode/decode routines.  This provides
 *	the "protocol" and "protocol generation tool" freedom to the bulk
 *	of the server.
 *
 * Functions included are:
 *	pbs_crypt_des()
 *	get_credential()
 *	process_request()
 *	set_to_non_blocking()
 *	clear_non_blocking()
 *	dispatch_request()
 *	close_client()
 *	close_quejob()
 */
#include <pbs_config.h>   /* the master config generated by configure */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <sys/types.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <memory.h>
#include <assert.h>
#ifndef WIN32
#include <fcntl.h>
#include <grp.h>
#include <pwd.h>
#include <dlfcn.h>
#endif
#include <ctype.h>
#include "libpbs.h"
#include "pbs_error.h"
#include "server_limits.h"
#include "list_link.h"
#include "attribute.h"
#include "job.h"
#include "server.h"
#include "user.h"
#include "credential.h"
#include "ticket.h"
#include "net_connect.h"
#include "batch_request.h"
#include "log.h"
#include "tpp.h"
#include "dis.h"
#include "pbs_nodes.h"
#include "svrfunc.h"
#include "pbs_sched.h"
#include "auth.h"

/* global data items */

pbs_list_head svr_requests;


extern struct server server;
extern char      server_host[];
extern pbs_list_head svr_newjobs;
extern pbs_list_head svr_allconns;
extern time_t    time_now;
extern char  *msg_err_noqueue;
extern char  *msg_err_malloc;
extern char  *msg_reqbadhost;
extern char  *msg_request;
extern char  *msg_auth_request;

extern int    is_local_root(char *, char *);
extern void   req_stat_hook(struct batch_request *);

static void close_quejob(int sfds);
/*
* @brief
 * 		process_request - process an request from the network:
 *		Call function to read in the request and decode it.
 *		Validate requesting host and user.
 *		Call function to process request based on type.
 *		That function MUST free the request by calling free_br()
 *
 * @param[in]	sfds	- file descriptor (socket) to get request
 */

void
process_request(int sfds)
{
	int rc;
	struct batch_request *request;
	conn_t *conn;
	int access_by_krb;

	time_now = time(NULL);

	conn = get_conn(sfds);

	if (!conn) {
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_REQUEST, LOG_ERR, __func__, "did not find socket in connection table");
		CLOSESOCKET(sfds);
		return;
	}

	if ((request = alloc_br(0)) == NULL) {
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_REQUEST, LOG_ERR, __func__, "Unable to allocate request structure");
		close_conn(sfds);
		return;
	}
	request->rq_conn = sfds;
	if (get_connecthost(sfds, request->rq_host, PBS_MAXHOSTNAME)) {
		log_eventf(PBSEVENT_DEBUG, PBS_EVENTCLASS_REQUEST, LOG_DEBUG, __func__, "%s: %lu", msg_reqbadhost, get_connectaddr(sfds));
		req_reject(PBSE_BADHOST, 0, request);
		return;
	}

	/*
	 * Read in the request and decode it to the internal request structure.
	 */
	if (conn->cn_active == FromClientDIS) {
		rc = dis_request_read(sfds, request);
	} else {
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_REQUEST, LOG_ERR, __func__, "request on invalid type of connection");
		close_conn(sfds);
		free_br(request);
		return;
	}

	if (rc == -1) { /* End of file */
		close_client(sfds);
		free_br(request);
		return;
	} else if ((rc == PBSE_SYSTEM) || (rc == PBSE_INTERNAL)) {
		/* read error, likely cannot send reply so just disconnect */

		/* ??? not sure about this ??? */

		close_client(sfds);
		free_br(request);
		return;
	} else if (rc > 0) {
		/*
		 * request didn't decode, either garbage or unknown
		 * request type, in ether case, return reject-reply
		 */
		req_reject(rc, 0, request);
		close_client(sfds);
		return;
	}

	strcpy(conn->cn_physhost, request->rq_host);
	if (conn->cn_username[0] == '\0')
		strcpy(conn->cn_username, request->rq_user);
	if (conn->cn_hostname[0] == '\0')
		strcpy(conn->cn_hostname, request->rq_host);
	if ((conn->cn_authen & PBS_NET_CONN_TO_SCHED) != 0) {
		/*
		 * If the request is coming on the socket we opened to the
		 * scheduler, change the "user" from "root" to "Scheduler"
		 */
		strncpy(request->rq_user, PBS_SCHED_DAEMON_NAME, PBS_MAXUSER);
		request->rq_user[PBS_MAXUSER] = '\0';
	}
	log_eventf(PBSEVENT_DEBUG2, PBS_EVENTCLASS_REQUEST, LOG_DEBUG, "", msg_request, request->rq_type, request->rq_user, request->rq_host, sfds);

	if (request->rq_type == PBS_BATCH_Authenticate) {
		req_authenticate(conn, request);
		return;
	}

	if ((conn->cn_authen & PBS_NET_CONN_TO_SCHED) == 0 && request->rq_type != PBS_BATCH_Connect) {
		if (transport_chan_get_ctx_status(sfds, FOR_AUTH) != AUTH_STATUS_CTX_READY &&
			(conn->cn_authen & PBS_NET_CONN_AUTHENTICATED) == 0) {
			req_reject(PBSE_BADCRED, 0, request);
			close_client(sfds);
			return;
		}

		if (conn->cn_credid == NULL &&
			conn->cn_auth_config != NULL &&
			conn->cn_auth_config->auth_method != NULL &&
			strcmp(conn->cn_auth_config->auth_method, AUTH_RESVPORT_NAME) != 0) {
			char *user = NULL;
			char *host = NULL;
			char *realm = NULL;
			auth_def_t *authdef = transport_chan_get_authdef(sfds, FOR_AUTH);

			if (authdef == NULL) {
				req_reject(PBSE_PERM, 0, request);
				close_client(sfds);
				return;
			}

			if (authdef->get_userinfo(transport_chan_get_authctx(sfds, FOR_AUTH), &user, &host, &realm) != 0) {
				req_reject(PBSE_PERM, 0, request);
				close_client(sfds);
				return;
			}

			if (user != NULL && realm != NULL) {
				size_t clen = strlen(user) + strlen(realm) + 2; /* 1 for '@' and 1 for '\0' */
				if ((conn->cn_credid = (char *)calloc(1, clen)) == NULL) {
					req_reject(PBSE_SYSTEM, errno, request);
					close_client(sfds);
					return;
				}
				strcpy(conn->cn_credid, user);
				strcat(conn->cn_credid, "@");
				strcat(conn->cn_credid, realm);
				free(realm);
			}

			if (user != NULL) {
				strcpy(conn->cn_username, user);
				free(user);
			}

			if (host != NULL) {
				strcpy(conn->cn_hostname, host);
				free(host);
			}
		}

		conn->cn_authen |= PBS_NET_CONN_AUTHENTICATED;
	}

	access_by_krb = 0;

	/* FIXME: Do we need realm check for all auth ? */
#if defined(PBS_SECURITY) && (PBS_SECURITY == KRB5)
	if (conn->cn_credid != NULL &&
		(conn->cn_authen & PBS_NET_CONN_TO_SCHED) == 0 &&
		conn->cn_auth_config != NULL &&
		conn->cn_auth_config->auth_method != NULL &&
		strcmp(conn->cn_auth_config->auth_method, AUTH_GSS_NAME) == 0) {
		strcpy(request->rq_user, conn->cn_username);
		strcpy(request->rq_host, conn->cn_hostname);

		log_eventf(PBSEVENT_DEBUG2, PBS_EVENTCLASS_REQUEST, LOG_DEBUG,
			"", msg_auth_request, request->rq_type, request->rq_user,
			request->rq_host, conn->cn_physhost, sfds);

		if (server.sv_attr[(int)SRV_ATR_acl_krb_realm_enable].at_val.at_long) {
			if (acl_check(&server.sv_attr[(int)SRV_ATR_acl_krb_realms], conn->cn_credid, ACL_Host) == 0) {
				req_reject(PBSE_PERM, 0, request);
				close_client(sfds);
				return;
			}
		}

		/* this principal is allowed to access the server */
		access_by_krb = 1;
	}
#endif

	/* is the request from a host acceptable to the server */
	if ((access_by_krb == 0) && (server.sv_attr[(int)SRV_ATR_acl_host_enable].at_val.at_long)) {
		/* acl enabled, check it; always allow myself	*/

		struct pbsnode *isanode = NULL;
		if ((server.sv_attr[SRV_ATR_acl_host_moms_enable].at_flags & ATR_VFLAG_SET) &&
			(server.sv_attr[(int)SRV_ATR_acl_host_moms_enable].at_val.at_long == 1)) {
			isanode = find_nodebyaddr(get_connectaddr(sfds));

			if ((isanode != NULL) && (isanode->nd_state & INUSE_DELETED))
				isanode = NULL;
		}

		if (isanode == NULL) {
			if ((acl_check(&server.sv_attr[(int)SRV_ATR_acl_hosts],
				request->rq_host, ACL_Host) == 0) &&
				(strcasecmp(server_host, request->rq_host) != 0)) {
					req_reject(PBSE_BADHOST, 0, request);
					close_client(sfds);
					return;
			}
		}
	}

	/*
	 * determine source (user client or another server) of request.
	 * set the permissions granted to the client
	 */
	if (conn->cn_authen & PBS_NET_CONN_FROM_PRIVIL) {

		/* request came from another server */

		request->rq_fromsvr = 1;
		request->rq_perm = ATR_DFLAG_USRD | ATR_DFLAG_USWR |
				   ATR_DFLAG_OPRD | ATR_DFLAG_OPWR |
				   ATR_DFLAG_MGRD | ATR_DFLAG_MGWR |
				   ATR_DFLAG_SvWR;

	} else {

		/* request not from another server */

		request->rq_fromsvr = 0;

		/*
		 * Client must be authenticated by a Authenticate User Request,
		 * if not, reject request and close connection.
		 * -- The following is retained for compat with old cmds --
		 * The exception to this is of course the Connect Request which
		 * cannot have been authenticated, because it contains the
		 * needed ticket; so trap it here.  Of course, there is no
		 * prior authentication on the Authenticate User request either,
		 * but it comes over a reserved port and appears from another
		 * server, hence is automatically granted authorization.

		 */

		if (request->rq_type == PBS_BATCH_Connect) {
			req_connect(request);
			return;
		}

		if ((conn->cn_authen & PBS_NET_CONN_AUTHENTICATED) == 0) {
			rc = PBSE_BADCRED;
		} else {
			rc = authenticate_user(request, conn);
		}
		if (rc != 0) {
			req_reject(rc, 0, request);
			if (rc == PBSE_BADCRED)
				close_client(sfds);
			return;
		}

		request->rq_perm = svr_get_privilege(request->rq_user, request->rq_host);
	}

	/* if server shutting down, disallow new jobs and new running */

	if (server.sv_attr[(int)SRV_ATR_State].at_val.at_long > SV_STATE_RUN) {
		switch (request->rq_type) {
			case PBS_BATCH_AsyrunJob:
			case PBS_BATCH_JobCred:
			case PBS_BATCH_UserCred:
			case PBS_BATCH_MoveJob:
			case PBS_BATCH_QueueJob:
			case PBS_BATCH_RunJob:
			case PBS_BATCH_StageIn:
			case PBS_BATCH_jobscript:
				req_reject(PBSE_SVRDOWN, 0, request);
				return;
		}
	}

	/*
	 * dispatch the request to the correct processing function.
	 * The processing function must call reply_send() to free
	 * the request struture.
	 */

	dispatch_request(sfds, request);
	return;
}

/**
 * @brief
 *		Set socket to non-blocking to prevent write from hanging up the
 *		Server for a long time.
 *
 *		This is called from dispatch_request() below for requests that will
 *		typically produce a large amout of output, such as stating all jobs.
 *		It is called after the incoming request has been read.  After the
 *		request is processed and replied to, the socket will be reset, see
 *		clear_non_blocking().  The existing socket flags are saved in the
 *		connection table entry cn_sockflgs for use by clear_non_blocking().
 *
 * @param[in] conn - the connection structure.
 *
 * @return	success or failure
 * @retval	-l	- failure
 * @retval 	0	- success
 */

static int
set_to_non_blocking(conn_t *conn)
{

	if (conn->cn_sock != PBS_LOCAL_CONNECTION) {

#ifndef WIN32

		int flg;
		flg = fcntl(conn->cn_sock, F_GETFL);
		if (((flg = fcntl(conn->cn_sock, F_GETFL)) == -1) ||
			(fcntl(conn->cn_sock, F_SETFL, flg|O_NONBLOCK) == -1)) {
			log_err(errno, __func__,
				"Unable to set client socking non-blocking");
			return -1;
		}
		conn->cn_sockflgs = flg;
#endif	/* WIN32 */
	}
	return 0;
}

/**
 * @brief
 *		Clear non-blocking from a socket.
 *
 *		The function set_to_non_blocking() must be called first, it saved
 *		the prior socket flags in the connection table.  This function resets
 *		the socket flags to that value.
 *
 @param[in] conn - the connection structure.
 */

static void
clear_non_blocking(conn_t *conn)
{
	if(!conn)
		return;
	if (conn->cn_sock != PBS_LOCAL_CONNECTION) {
#ifndef WIN32
		int flg;
		if ((flg = conn->cn_sockflgs) != -1)
			/* reset socket flag to prior value */
			(void)fcntl(conn->cn_sock, F_SETFL, flg);
		conn->cn_sockflgs = 0;
#endif /* WIN32 */
	}
}

/**
 * @brief
 * 		Determine the request type and invoke the corresponding
 *		function.
 * @par
 *		The function will perform the request action and return the
 *		reply.  The function MUST also reply and free the request by calling
 *		reply_send().
 *
 * @param[in]	sfds	- socket connection
 * @param[in]	request - the request information
 */

void
dispatch_request(int sfds, struct batch_request *request)
{

	conn_t *conn = NULL;
	int prot = request->prot;

	if (prot == PROT_TCP) {
		if (sfds != PBS_LOCAL_CONNECTION) {
			conn = get_conn(sfds);
			if (!conn) {
				log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_REQUEST, LOG_ERR, __func__, "did not find socket in connection table");
				req_reject(PBSE_SYSTEM, 0, request);
				close_client(sfds);
				return;
			}
		}
	}

	switch (request->rq_type) {

		case PBS_BATCH_QueueJob:
			if (prot == PROT_TPP) {
				request->tpp_ack = 0;
				tpp_add_close_func(sfds, close_quejob);
			} else
				net_add_close_func(sfds, close_quejob);
			req_quejob(request);
			break;

		case PBS_BATCH_JobCred:
			if (prot == PROT_TPP)
				request->tpp_ack = 0;
			req_jobcredential(request);
			break;

		case PBS_BATCH_UserCred:
			req_usercredential(request);
			break;

		case PBS_BATCH_jobscript:
			if (prot == PROT_TPP)
				request->tpp_ack = 0;
			req_jobscript(request);
			break;

			/*
			 * The PBS_BATCH_Rdytocommit message is deprecated.
			 * The server does not do anything with it anymore, but
			 * simply acks the request (in case some client makes this call)
			 */
		case PBS_BATCH_RdytoCommit:
			if (prot == PROT_TPP)
				request->tpp_ack = 0;
			reply_ack(request);
			break;

		case PBS_BATCH_Commit:
			if (prot == PROT_TPP)
				request->tpp_ack = 0;
			req_commit(request);
			if (prot == PROT_TPP)
				tpp_add_close_func(sfds, (void (*)(int))0);
			else
				net_add_close_func(sfds, (void (*)(int))0);
			break;

		case PBS_BATCH_DeleteJob:
			log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
				request->rq_ind.rq_delete.rq_objname,
				"delete job request received");
			req_deletejob(request);
			break;

		case PBS_BATCH_SubmitResv:
			req_resvSub(request);
			break;

		case PBS_BATCH_DeleteResv:
			req_deleteReservation(request);
			break;

		case PBS_BATCH_ModifyResv:
			req_modifyReservation(request);
			break;

		case PBS_BATCH_ResvOccurEnd:
			req_reservationOccurrenceEnd(request);
			break;

		case PBS_BATCH_HoldJob:
			if (sfds != PBS_LOCAL_CONNECTION && prot == PROT_TCP)
				conn->cn_authen |= PBS_NET_CONN_NOTIMEOUT;
			req_holdjob(request);
			break;

		case PBS_BATCH_PreemptJobs:
			req_preemptjobs(request);
			break;

		case PBS_BATCH_LocateJob:
			req_locatejob(request);
			break;

		case PBS_BATCH_Manager:
			req_manager(request);
			break;

		case PBS_BATCH_RelnodesJob:
			req_relnodesjob(request);
			break;

		case PBS_BATCH_MessJob:
			req_messagejob(request);
			break;

		case PBS_BATCH_PySpawn:
			if (sfds != PBS_LOCAL_CONNECTION && prot == PROT_TCP)
				conn->cn_authen |= PBS_NET_CONN_NOTIMEOUT;
			req_py_spawn(request);
			break;

		case PBS_BATCH_ModifyJob:
		case PBS_BATCH_ModifyJob_Async:
			req_modifyjob(request);
			break;

		case PBS_BATCH_Rerun:
			req_rerunjob(request);
			break;

		case PBS_BATCH_MoveJob:
			req_movejob(request);
			break;

		case PBS_BATCH_OrderJob:
			req_orderjob(request);
			break;

		case PBS_BATCH_Rescq:
			req_reject(PBSE_NOSUP, 0, request);
			break;

		case PBS_BATCH_ReserveResc:
			req_reject(PBSE_NOSUP, 0, request);
			break;

		case PBS_BATCH_ReleaseResc:
			req_reject(PBSE_NOSUP, 0, request);
			break;

		case PBS_BATCH_ReleaseJob:
			if (sfds != PBS_LOCAL_CONNECTION && prot == PROT_TCP)
				conn->cn_authen |= PBS_NET_CONN_NOTIMEOUT;
			req_releasejob(request);
			break;

		case PBS_BATCH_RunJob:
		case PBS_BATCH_AsyrunJob:
			req_runjob(request);
			break;

		case PBS_BATCH_DefSchReply:
			req_defschedreply(request);
			break;

		case PBS_BATCH_ConfirmResv:
			req_confirmresv(request);
			break;

		case PBS_BATCH_SelectJobs:
		case PBS_BATCH_SelStat:
			req_selectjobs(request);
			break;

		case PBS_BATCH_Shutdown:
			req_shutdown(request);
			break;

		case PBS_BATCH_SignalJob:
			log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
				request->rq_ind.rq_signal.rq_jid,
				"signal job request received");
			req_signaljob(request);
			break;

		case PBS_BATCH_MvJobFile:
			req_mvjobfile(request);
			break;

		case PBS_BATCH_StatusJob:
			if (set_to_non_blocking(conn) == -1) {
				req_reject(PBSE_SYSTEM, 0, request);
				close_client(sfds);
				return;
			}
			req_stat_job(request);
			clear_non_blocking(get_conn(sfds));
			break;

		case PBS_BATCH_StatusQue:
			if (set_to_non_blocking(conn) == -1) {
				req_reject(PBSE_SYSTEM, 0, request);
				close_client(sfds);
				return;
			}
			req_stat_que(request);
			clear_non_blocking(get_conn(sfds));
			break;

		case PBS_BATCH_StatusNode:
			if (set_to_non_blocking(conn) == -1) {
				req_reject(PBSE_SYSTEM, 0, request);
				close_client(sfds);
				return;
			}
			req_stat_node(request);
			clear_non_blocking(get_conn(sfds));
			break;

		case PBS_BATCH_StatusResv:
			if (set_to_non_blocking(conn) == -1) {
				req_reject(PBSE_SYSTEM, 0, request);
				close_client(sfds);
				return;
			}
			req_stat_resv(request);
			clear_non_blocking(get_conn(sfds));
			break;

		case PBS_BATCH_StatusSvr:
			req_stat_svr(request);
			break;

		case PBS_BATCH_StatusSched:
			req_stat_sched(request);
			break;

		case PBS_BATCH_StatusHook:
			if (!is_local_root(request->rq_user, request->rq_host)) {
				sprintf(log_buffer, "%s@%s is unauthorized to "
					"access hooks data from server %s",
					request->rq_user, request->rq_host, server_host);
				reply_text(request, PBSE_HOOKERROR, log_buffer);
				log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_HOOK,
					LOG_INFO, "", log_buffer);
				/* don't call close_client() to allow other */
				/* non-hook related requests to continue */
				break;
			}

			if (set_to_non_blocking(conn) == -1) {
				req_reject(PBSE_SYSTEM, 0, request);
				close_client(sfds);
				return;
			}
			req_stat_hook(request);
			clear_non_blocking(get_conn(sfds));
			break;

		case PBS_BATCH_TrackJob:
			req_track(request);
			break;

		case PBS_BATCH_RegistDep:
			req_register_dep(request);
			break;

		case PBS_BATCH_StageIn:
			req_stagein(request);
			break;

		case PBS_BATCH_FailOver:
			req_failover(request);
			break;

		case PBS_BATCH_StatusRsc:
			req_stat_resc(request);
			break;

		default:
			req_reject(PBSE_UNKREQ, 0, request);
			close_client(sfds);
			break;
	}
	return;
}

/**
 * @brief
 * 		close_quejob - locate and deal with the new job that was being received
 *		  when the net connection closed.
 *
 * @param[in]	sfds	- file descriptor (socket) to get request
 */

static void
close_quejob(int sfds)
{
	svrjob_t *pjob;

	pjob = (svrjob_t *)GET_NEXT(svr_newjobs);
	while (pjob  != NULL) {
		if (pjob->ji_qs.ji_un.ji_newt.ji_fromsock == sfds) {
			if (pjob->ji_qs.ji_substate == JOB_SUBSTATE_TRANSICM) {
				if (pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) {

					/*
					 * the job was being created here for the first time
					 * go ahead and enqueue it as QUEUED; otherwise, hold
					 * it here as TRANSICM until we hear from the sending
					 * server again to commit.
					 */
					delete_link(&pjob->ji_alljobs);
					pjob->ji_qs.ji_state = JOB_STATE_QUEUED;
					pjob->ji_qs.ji_substate = JOB_SUBSTATE_QUEUED;
					if (svr_enquejob(pjob))
						(void)job_abt(pjob, msg_err_noqueue);

				}
			} else {

				/* else delete the job */

				delete_link(&pjob->ji_alljobs);
				job_purge_generic(pjob);
			}
			break;
		}
		pjob = GET_NEXT(pjob->ji_alljobs);
	}
	return;
}
